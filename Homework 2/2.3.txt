1.
    a.
        999=1+(n−1)×2
        n=500

        500/2 [2a+(n-1)d]
        500/2 [(2×1)+(500−1)×2]
        250[1000]

        250000
    b.
        r = 2

        a1[1-2^n] / 1-r
        2[1-2^10] / 1-2
        = 2046
    c.
        (n+1) + 1
    d.
        3 + 4 + 5 + ... + n+1
    e.
        0 + 2 + 6 + 12 + 20 + 30 + 42 + 56 + ... + (n-1)(n)
    f.
        9 + 27 + 81 + 243 + ... + 3^(n+1)
    g.
        1*1 + 1*2 + 1*3 + ... + 2*1 + 2*2 + 2*3 ... + n*n
    h
        1/2 + 1/6 + 1/12 + 1/20 + ... 1/n(n+1)
2.
    a.
        i^4 + 2i^2 + 1 = (n-1)^4 + 2(n-1)^2 + 1
        O(n^4)
    b.
        lg i^2 = 2 log i = 2 log (n-1)
        O(log(n^2))
    c.
        (n + 1)2^(n-1)
        O(n * 2^n)
    d.
        Sum n-1 starting 0 = (i + i - 1) = (2i - 1) = (2(n-1) - 1) = (2n - 2 - 1) = (2n - 3)
        O(n)
5.
    a.
        it computes the distance between the biggest and smallest numbers in an array
    b.
        it's basic operation is the comparison
    c.
        this basic operation is being executed (n-2) times twice because of the two comparisons, making it 2(n-2) times (n-2 because the i starts at 1 and not 0)
    d.
        it's efficiency class is O(n^2) because it has to reloop through the array n-1 amount of times, making it n*n = n^2
    e.
        sorting the array would be the best course of action here. There are sorting algorithms such as the block sort that would be stable and in-place while giving an efficiency of nlogn in worst case and n in best case. After doing this, a simple calculation of a[n-1] - a[0] is needed to calculate the difference, essentially making the efficiency class go from an O(n^2) to a O(nlogn)


